<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Story Music Generator (Mood + Prompt)</title>
  <style>
    :root { --pad: 14px; --radius: 14px; }
    body { font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
           margin: 0; background: #0b0c10; color: #e8e8ea; }
    header { padding: calc(var(--pad) + env(safe-area-inset-top)) var(--pad) var(--pad);
             border-bottom: 1px solid rgba(255,255,255,.08);
             position: sticky; top: 0; background: rgba(11,12,16,.92); backdrop-filter: blur(10px); }
    header h1 { margin: 0; font-size: 18px; letter-spacing: .2px; }
    header p { margin: 6px 0 0; font-size: 13px; opacity: .82; line-height: 1.35; }
    main { padding: var(--pad); padding-bottom: calc(var(--pad) + env(safe-area-inset-bottom)); max-width: 1040px; margin: 0 auto; }
    .card { background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08);
            border-radius: var(--radius); padding: var(--pad); box-shadow: 0 6px 30px rgba(0,0,0,.25); }
    .row { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 900px) { .row { grid-template-columns: 1.25fr .75fr; } }
    button { appearance: none; border: 1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.08);
             color: #fff; padding: 12px 14px; border-radius: 12px; font-size: 15px; font-weight: 700; }
    button:active { transform: translateY(1px); }
    button.primary { background: rgba(34,197,94,.18); border-color: rgba(34,197,94,.35); }
    button.warn { background: rgba(245,158,11,.16); border-color: rgba(245,158,11,.35); }
    button.danger { background: rgba(239,68,68,.16); border-color: rgba(239,68,68,.35); }
    .btns { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .btns .spacer { flex: 1; min-width: 10px; }
    .kv { display:flex; align-items:center; justify-content: space-between; gap: 10px; font-size: 13px; opacity: .92; }
    .kv b { font-weight: 800; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 640px) { .grid { grid-template-columns: 1fr 1fr; } }
    .control { padding: 10px; border-radius: 12px; border: 1px solid rgba(255,255,255,.08); background: rgba(0,0,0,.18); }
    .control label { display:flex; align-items:center; justify-content: space-between; font-size: 13px; opacity: .95; }
    .control label span { opacity: .8; }
    input[type="range"], select, textarea { width:100%; margin-top: 8px; }
    input[type="range"]{ -webkit-appearance: none; appearance: none; height: 26px; background: transparent; }
    input[type="range"]::-webkit-slider-runnable-track { height: 6px; border-radius: 999px; background: rgba(255,255,255,.18); }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance:none; appearance:none; width: 22px; height: 22px; border-radius: 50%;
      margin-top: -8px; background: rgba(255,255,255,.92); border: 2px solid rgba(0,0,0,.35); }
    select, textarea {
      border-radius: 12px; border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25); color: #fff; padding: 10px 12px; font-size: 14px;
      outline: none;
    }
    textarea { min-height: 76px; resize: vertical; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            font-size: 12px; white-space: pre-wrap; opacity: .9; }
    .small { font-size: 12px; opacity: .78; line-height: 1.35; }
    .pill { display:inline-block; padding: 6px 10px; border-radius: 999px; border:1px solid rgba(255,255,255,.12);
            background: rgba(255,255,255,.06); font-size: 12px; opacity: .9; }
    .pill.ok { border-color: rgba(34,197,94,.35); background: rgba(34,197,94,.12); }
    .pill.bad { border-color: rgba(239,68,68,.35); background: rgba(239,68,68,.12); }
    .divider { height: 1px; background: rgba(255,255,255,.08); margin: 12px 0; }
    #gate {
      position: fixed; inset: 0; z-index: 9999;
      display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,.70); backdrop-filter: blur(10px);
      padding: 22px;
    }
    #gate .panel {
      max-width: 620px; width: 100%;
      border-radius: 18px; padding: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(15,16,20,.92);
      box-shadow: 0 12px 60px rgba(0,0,0,.55);
    }
    #gate h2 { margin: 0 0 8px; font-size: 18px; }
    #gate p { margin: 0 0 12px; font-size: 13px; opacity: .85; line-height: 1.35; }
    #gate .hint { margin-top: 10px; font-size: 12px; opacity: .75; }
    #gate.hidden { display: none; }
    canvas { width: 100%; height: 120px; border-radius: 12px; background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.08); }
  </style>
</head>
<body>
  <div id="gate">
    <div class="panel">
      <h2>Tap to start audio</h2>
      <p>This app composes a multi‑section piece (Intro → A → A′ → Bridge → Climax → Outro). Choose mood (1–4) and add a prompt like “sunrise on a mountain” or “rainy night drive.”</p>
      <div class="btns">
        <button id="unlockBtn" class="primary">Start</button>
        <span id="gateStatus" class="pill bad">Locked</span>
      </div>
      <div class="hint">If silent: switch off Silent Mode, raise volume, and keep phone unmuted.</div>
    </div>
  </div>

  <header>
    <h1>Story Music Generator</h1>
    <p>Mood 1–4 + prompt → structured music with motifs, phrasing, tension/release, and evolving arrangement. Lead instrument includes piano, classic guitar, electric guitar, sax, keyboard. Octave range up to 6.</p>
  </header>

  <main>
    <div class="row">
      <section class="card">
        <div class="btns">
          <button id="playBtn" class="primary" disabled>Play</button>
          <button id="stopBtn" class="danger" disabled>Stop</button>
          <button id="composeBtn" class="warn" disabled>Compose from prompt</button>
          <div class="spacer"></div>
          <span id="statusPill" class="pill bad">Engine: off</span>
        </div>

        <div class="divider"></div>

        <div class="grid">
          <div class="control">
            <label><b>Mood (1–4)</b> <span id="moodVal">3</span></label>
            <input id="mood" type="range" min="1" max="4" value="3" step="1">
            <div class="small" style="margin-top:6px">
              <b>1</b> Hopeful / uplifting · <b>2</b> Melancholy / reflective · <b>3</b> Tense → triumphant · <b>4</b> Romantic / warm
            </div>
          </div>

          <div class="control">
            <label><b>Prompt</b> <span id="promptHint" class="pill">short phrase</span></label>
            <textarea id="prompt" placeholder="Example: ‘lost in a foggy forest, then finding the way home’"></textarea>
            <div class="small" style="margin-top:6px">Prompt steers key, tempo, brightness, motif contour, and section intensity.</div>
          </div>

          <div class="control">
            <label><b>Instrument</b> <span id="instVal">Piano</span></label>
            <input id="instrument" type="range" min="0" max="4" value="0" step="1">
          </div>

          <div class="control">
            <label><b>Tempo</b> <span><span id="tempoVal">110</span> BPM</span></label>
            <input id="tempo" type="range" min="70" max="160" value="110" step="1">
          </div>

          <div class="control">
            <label><b>Octave range</b> <span id="octVal">5.0</span></label>
            <input id="octave" type="range" min="1" max="6" value="5.0" step="0.1">
          </div>

          <div class="control">
            <label><b>Expressiveness</b> <span id="exprVal">0.75</span></label>
            <input id="express" type="range" min="0" max="1" value="0.75" step="0.01">
          </div>

          <div class="control">
            <label><b>Drums</b> <span id="drumsVal">0.65</span></label>
            <input id="drums" type="range" min="0" max="1" value="0.65" step="0.01">
          </div>

          <div class="control">
            <label><b>Bass</b> <span id="bassVal">0.75</span></label>
            <input id="bass" type="range" min="0" max="1" value="0.75" step="0.01">
          </div>

          <div class="control">
            <label><b>Lead</b> <span id="leadVal">0.85</span></label>
            <input id="lead" type="range" min="0" max="1" value="0.85" step="0.01">
          </div>

          <div class="control">
            <label><b>Reverb</b> <span id="revVal">0.40</span></label>
            <input id="reverb" type="range" min="0" max="1" value="0.40" step="0.01">
          </div>
        </div>

        <div class="divider"></div>
        <div class="kv"><span>Now playing</span> <b id="nowPlaying">—</b></div>
        <div class="small">
          Use <b>Compose from prompt</b> after changing mood/prompt. The piece is ~44 bars with a clear arc.
          If it still feels “robotic,” raise <b>Expressiveness</b> and lower drums slightly.
        </div>
      </section>

      <aside class="card">
        <div class="kv"><span>Diagnostics</span> <span id="diag" class="pill bad">Not started</span></div>
        <div class="divider"></div>
        <canvas id="scope" width="600" height="180"></canvas>
        <div class="divider"></div>
        <div class="mono" id="log"></div>
        <div class="divider"></div>
        <div class="small">
          This generator focuses on “music storytelling”: motif → development → contrast → climax → resolution.
          It’s still synthesized (no samples), but composition is structured and intentional.
        </div>
      </aside>
    </div>
  </main>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  const pill = $("statusPill");
  const diag = $("diag");

  function log(msg) {
    const t = new Date().toLocaleTimeString();
    logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent;
  }
  window.addEventListener("error", (e) => log(`ERROR: ${e.message}`));
  window.addEventListener("unhandledrejection", (e) => log(`PROMISE REJECTED: ${e.reason?.message || e.reason}`));

  const instNames = ["Piano","Classic guitar","Electric guitar","Sax","Keyboard"];
  function bindRange(id, labelId, fmt=(v)=>v) {
    const el = $(id), out = $(labelId);
    const update = () => { out.textContent = fmt(el.value); };
    el.addEventListener("input", update, { passive: true });
    update();
    return el;
  }

  const moodEl  = bindRange("mood","moodVal",(v)=>String(v));
  const tempoEl = bindRange("tempo","tempoVal",(v)=>String(v));
  const octEl   = bindRange("octave","octVal",(v)=>Number(v).toFixed(1));
  const exprEl  = bindRange("express","exprVal",(v)=>Number(v).toFixed(2));
  const drumsEl = bindRange("drums","drumsVal",(v)=>Number(v).toFixed(2));
  const bassEl  = bindRange("bass","bassVal",(v)=>Number(v).toFixed(2));
  const leadEl  = bindRange("lead","leadVal",(v)=>Number(v).toFixed(2));
  const revEl   = bindRange("reverb","revVal",(v)=>Number(v).toFixed(2));
  const instEl  = bindRange("instrument","instVal",(v)=>instNames[Number(v)]);

  const promptEl = $("prompt");
  const playBtn = $("playBtn");
  const stopBtn = $("stopBtn");
  const composeBtn = $("composeBtn");
  const nowPlaying = $("nowPlaying");

  // ---------- Audio Engine ----------
  let ctx = null;
  let master = null, limiter = null, analyser = null;
  let revSend = null, revReturn = null;
  let drumBus = null, bassBus = null, leadBus = null, chordBus = null;
  let playing = false;
  let stepTimer = null;
  let currentStep = 0;
  let piece = null;

  const scope = $("scope");
  const sctx = scope.getContext("2d");

  function setEngineOn(on) {
    pill.textContent = on ? "Engine: on" : "Engine: off";
    pill.classList.toggle("ok", on);
    pill.classList.toggle("bad", !on);
    diag.textContent = on ? "Audio ready" : "Not started";
    diag.classList.toggle("ok", on);
    diag.classList.toggle("bad", !on);
    playBtn.disabled = !on;
    composeBtn.disabled = !on;
  }

  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
  function midiToHz(m){ return 440 * Math.pow(2, (m - 69)/12); }
  function randf(a,b){ return a + Math.random()*(b-a); }
  function randi(a,b){ return Math.floor(randf(a,b+1)); }
  function choice(arr) { return arr[Math.floor(Math.random()*arr.length)]; }

  function hashStr(s) {
    let h = 2166136261 >>> 0;
    for (let i=0;i<s.length;i++) {
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function seededRng(seed) {
    let t = seed >>> 0;
    return function() {
      t ^= t << 13; t >>>= 0;
      t ^= t >> 17; t >>>= 0;
      t ^= t << 5;  t >>>= 0;
      return (t >>> 0) / 4294967296;
    };
  }

  function makeConvolverReverb(context) {
    const rate = context.sampleRate;
    const seconds = 1.9;
    const len = Math.floor(rate * seconds);
    const buf = context.createBuffer(2, len, rate);
    for (let c = 0; c < 2; c++) {
      const data = buf.getChannelData(c);
      for (let i = 0; i < len; i++) {
        const tt = i / len;
        const decay = Math.pow(1 - tt, 3.2);
        data[i] = (Math.random()*2 - 1) * decay;
      }
    }
    const con = context.createConvolver();
    con.buffer = buf;
    return con;
  }

  function makeLimiter(context) {
    const comp = context.createDynamicsCompressor();
    comp.threshold.value = -12;
    comp.knee.value = 16;
    comp.ratio.value = 10;
    comp.attack.value = 0.003;
    comp.release.value = 0.12;
    return comp;
  }

  function ensureContext() {
    if (ctx) return ctx;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    ctx = new AudioContext({ latencyHint: "interactive" });

    master = ctx.createGain();
    master.gain.value = 0.9;

    limiter = makeLimiter(ctx);
    analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;

    drumBus = ctx.createGain();
    bassBus = ctx.createGain();
    leadBus = ctx.createGain();
    chordBus = ctx.createGain();

    revSend = ctx.createGain();
    revReturn = ctx.createGain();
    revReturn.gain.value = 0.35;

    const convolver = makeConvolverReverb(ctx);
    revSend.connect(convolver);
    convolver.connect(revReturn);

    drumBus.connect(master);
    bassBus.connect(master);
    leadBus.connect(master);
    chordBus.connect(master);
    revReturn.connect(master);

    master.connect(limiter);
    limiter.connect(analyser);
    analyser.connect(ctx.destination);

    log(`AudioContext created @ ${ctx.sampleRate} Hz`);
    return ctx;
  }

  async function unlockAudio() {
    ensureContext();
    if (ctx.state !== "running") await ctx.resume();

    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = "sine";
    o.frequency.value = 880;
    g.gain.value = 0.0001;
    o.connect(g); g.connect(ctx.destination);
    const t0 = ctx.currentTime;
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(0.02, t0 + 0.005);
    g.gain.linearRampToValueAtTime(0.0001, t0 + 0.015);
    o.start(t0); o.stop(t0 + 0.02);

    setEngineOn(true);
    $("gateStatus").textContent = "Unlocked";
    $("gateStatus").classList.remove("bad");
    $("gateStatus").classList.add("ok");
    $("gate").classList.add("hidden");

    stopBtn.disabled = false;
    composeFromPrompt(true);
    updateMix();
    log("Unlocked + composed.");
  }

  // ---------- Musical building blocks ----------
  const majorScale = [0,2,4,5,7,9,11];
  const minorScale = [0,2,3,5,7,8,10];

  function chordTones(root, quality) {
    const third = (quality === "min") ? 3 : 4;
    return [0, third, 7, 10];
  }

  function diatonicTriadQuality(mode, degree) {
    if (mode === "maj") {
      return ["maj","min","min","maj","maj","min","dim"][degree];
    } else {
      return ["min","dim","maj","min","min","maj","maj"][degree];
    }
  }

  function makeProgressionsForMood(mood) {
    if (mood === 1) return { mode:"maj", progs:[[5,3,0,4],[0,4,5,3],[0,3,4,0]] };
    if (mood === 2) return { mode:"min", progs:[[0,5,2,6],[0,3,6,6],[0,5,6,3]] };
    if (mood === 3) return { mode:"min", progs:[[0,5,2,4],[0,6,5,4],[0,3,4,0]] };
    return { mode:"maj", progs:[[0,5,3,4],[0,3,5,4],[0,4,5,0]] };
  }

  function chooseKeyFromPrompt(mood, prompt) {
    const h = hashStr(prompt.trim().toLowerCase() || "default");
    const key = h % 12;
    if (mood === 2) return (key + 3) % 12;
    if (mood === 3) return (key + 7) % 12;
    return key;
  }

  function chooseTempoFromPrompt(mood, prompt) {
    const p = prompt.toLowerCase();
    let base = (mood===2) ? 92 : (mood===1 ? 112 : (mood===3 ? 116 : 104));
    if (p.includes("chase") || p.includes("run") || p.includes("battle")) base += 16;
    if (p.includes("rain") || p.includes("night") || p.includes("lonely") || p.includes("fog")) base -= 10;
    if (p.includes("sunrise") || p.includes("hope") || p.includes("home")) base += 6;
    return clamp(Math.round(base), 70, 160);
  }

  function motifFromPrompt(mode, key, prompt, rng) {
    const scale = (mode === "maj") ? majorScale : minorScale;
    const len = 6 + Math.floor(rng()*3);
    let deg = 0;
    const motif = [];
    for (let i=0;i<len;i++) {
      const r = rng();
      let step = 0;
      if (r < 0.55) step = choice([-1,1]);
      else if (r < 0.85) step = choice([-2,2]);
      else step = choice([-3,3]);
      deg = clamp(deg + step, 0, 6);
      motif.push(scale[deg]);
    }
    motif[len-1] = 0;
    motif[len-2] = choice([2,7,9,11].map(x => x%12));
    const p = prompt.toLowerCase();
    if (p.includes("rise") || p.includes("sun") || p.includes("up")) motif[len-2] = scale[5];
    if (p.includes("fall") || p.includes("down") || p.includes("sorrow")) motif[len-2] = scale[2];
    return motif.map(pc => (key + pc) % 12);
  }

  function composeFromPrompt(reset=true) {
    const mood = Number(moodEl.value);
    const prompt = promptEl.value.trim();
    const seed = hashStr(`${mood}|${instEl.value}|${prompt}`);
    const rng = seededRng(seed);

    const spec = makeProgressionsForMood(mood);
    const mode = spec.mode;
    const key = chooseKeyFromPrompt(mood, prompt || "default");
    const tempo = chooseTempoFromPrompt(mood, prompt || "default");
    tempoEl.value = String(tempo);
    $("tempoVal").textContent = String(tempo);

    const octaveRange = Number(octEl.value);
    const spreadSemis = Math.round(octaveRange * 12);
    const baseMidi = 60;
    const leadMin = baseMidi - Math.floor(spreadSemis*0.60);
    const leadMax = baseMidi + Math.floor(spreadSemis*0.75);

    const expr = Number(exprEl.value);

    const sections = [
      { name:"Intro",  bars:2,  intensity:0.25 },
      { name:"Theme A",bars:8,  intensity:0.45 },
      { name:"Theme A′",bars:8, intensity:0.55 },
      { name:"Bridge", bars:8,  intensity:0.60 },
      { name:"Climax", bars:8,  intensity:0.85 },
      { name:"Outro",  bars:4,  intensity:0.35 },
    ];

    const motif = motifFromPrompt(mode, key, prompt || "default", rng);
    const motifLen = motif.length;

    const rhythmsA = [
      [0,4,8,12],
      [0,6,8,14],
      [0,4,7,10,12],
      [0,3,6,8,11,14],
    ];
    const rhythmsB = [
      [0,2,4,7,8,10,12,14],
      [0,1,3,4,6,7,8,10,11,12,14],
      [0,4,6,8,10,12,15],
      [0,2,5,7,9,12,14,15],
    ];
    const rA = rhythmsA[Math.floor(rng()*rhythmsA.length)];
    const rB = rhythmsB[Math.floor(rng()*rhythmsB.length)];

    const progA = choice(spec.progs);
    const progB = choice(spec.progs);
    const progBridge = (mood === 3 && rng() < 0.7) ? [0, 1, 4, 4] : choice(spec.progs);

    const stepsPerBar = 16;
    const totalBars = sections.reduce((a,s)=>a+s.bars,0);
    const totalSteps = totalBars * stepsPerBar;

    let leadCenter = clamp(randi(leadMin+8, leadMax-8), leadMin, leadMax);
    const seq = [];
    let barGlobal = 0;
    let motifIndex = 0;

    function degreeToPc(deg, mode) {
      const scale = (mode==="maj") ? majorScale : minorScale;
      return scale[deg % 7];
    }

    function chooseChord(barInSection, progDegrees) {
      const deg = progDegrees[barInSection % progDegrees.length];
      const rootPc = (key + degreeToPc(deg, mode)) % 12;
      const q = diatonicTriadQuality(mode, deg);
      return { rootPc, q, deg };
    }

    function pickLeadNotePc(chord, sectionName, stepInBar) {
      const isCadence = (stepInBar === 12 || stepInBar === 14 || stepInBar === 15);
      const chordT = chordTones(chord.rootPc, chord.q).map(x => (chord.rootPc + x) % 12);
      const scale = (mode==="maj") ? majorScale : minorScale;

      let pc;
      const useMotif = rng() < (0.72 + 0.10*expr);
      if (useMotif) {
        pc = motif[motifIndex % motifLen];
        motifIndex += 1;
      } else {
        pc = (key + choice(scale)) % 12;
      }

      if (isCadence && rng() < (0.55 + 0.35*expr)) pc = choice([key, chord.rootPc, chordT[1], chordT[2]]);
      if (sectionName === "Outro") pc = (rng() < 0.65) ? key : pc;
      if (sectionName === "Bridge" && rng() < 0.18*expr) pc = (pc + choice([-1,1]) + 12) % 12;
      if (rng() < 0.35) pc = choice(chordT);
      return pc;
    }

    function pcToNearestMidi(pc, center) {
      let best = center, bestDist = 999;
      for (let m = center - 48; m <= center + 48; m++) {
        const p = ((m % 12) + 12) % 12;
        if (p === pc) {
          const d = Math.abs(m - center);
          if (d < bestDist) { bestDist = d; best = m; }
        }
      }
      return best;
    }

    function drumAt(stepInBar, intensity, sectionName) {
      const kick = (stepInBar===0 || (intensity>0.6 && stepInBar===8) || (sectionName==="Climax" && (stepInBar===4 || stepInBar===12))) ? 1 : 0;
      const snare = (stepInBar===4 || stepInBar===12) ? 1 : 0;
      const hatProb = clamp(0.20 + 0.70*intensity, 0.1, 0.95);
      const hat = (rng() < hatProb) ? 1 : 0;
      return { kick, snare: (sectionName==="Intro"||sectionName==="Outro") ? (snare && rng()<0.5?1:0) : snare, hat };
    }

    function bassFor(stepInBar, chord, intensity, sectionName) {
      const slots = (intensity < 0.45) ? [0,8] : [0,6,8,12];
      if (!slots.includes(stepInBar)) return null;
      const base = (mode==="maj") ? 36 : 35;
      let pc = chord.rootPc;
      if (rng() < (0.20 + 0.25*intensity)) pc = (chord.rootPc + 7) % 12;
      if (sectionName==="Bridge" && rng() < 0.25*expr) pc = (pc + choice([-2,2])) % 12;
      const oct = (rng() < (0.06 + 0.12*intensity)) ? 12 : 0;
      return base + pc + oct;
    }

    for (const sec of sections) {
      const prog = (sec.name==="Bridge") ? progBridge : (sec.name==="Climax" ? progB : progA);
      for (let b = 0; b < sec.bars; b++) {
        const chord = chooseChord(b, prog);
        const rhythm = (sec.intensity < 0.55) ? rA : rB;
        const barAccent = (sec.name==="Climax") ? 0.18 : 0.0;

        for (let s = 0; s < stepsPerBar; s++) {
          const stepInBar = s;
          const onGrid = rhythm.includes(stepInBar);
          const leadProb = clamp(0.18 + 0.75*sec.intensity + 0.20*expr, 0.12, 0.95);
          const isPhraseEnd = (stepInBar >= 14);
          const breathe = isPhraseEnd && (rng() < (0.55 - 0.25*sec.intensity + 0.20*expr));

          let leadMidi = null;
          let velLead = 0.0;
          if (onGrid && rng() < leadProb && !breathe) {
            const pc = pickLeadNotePc(chord, sec.name, stepInBar);
            if (stepInBar === 0) {
              const drift = (sec.name==="Climax") ? 2 : (sec.name==="Outro" ? -2 : 1);
              leadCenter = clamp(leadCenter + randi(-2, drift+2), leadMin, leadMax);
            }
            let m = pcToNearestMidi(pc, leadCenter);
            if (rng() < (0.08 + 0.18*sec.intensity*expr)) m += choice([-12,12,24,-24]);
            leadMidi = clamp(m, leadMin, leadMax);

            const baseVel = clamp(0.45 + 0.45*sec.intensity + 0.15*expr, 0.25, 0.98);
            const cadenceBoost = (stepInBar >= 12) ? (0.08 + 0.14*expr) : 0;
            velLead = clamp(baseVel + cadenceBoost + barAccent + randf(-0.10,0.10)*(0.4+0.7*expr), 0.18, 1.0);
          }

          const drums = drumAt(stepInBar, sec.intensity, sec.name);
          const bassMidi = bassFor(stepInBar, chord, sec.intensity, sec.name);
          const dropout = (rng() < (0.006 + 0.020*expr)) && (stepInBar===0) && (sec.name!=="Climax");

          seq.push({
            section: sec.name,
            intensity: sec.intensity,
            barGlobal, stepInBar,
            chordRoot: chord.rootPc, chordQ: chord.q,
            kick: dropout ? 0 : drums.kick,
            snare: dropout ? 0 : drums.snare,
            hat: dropout ? 0 : drums.hat,
            bass: dropout ? null : bassMidi,
            lead: dropout ? null : leadMidi,
            velLead: velLead,
          });
        }
        barGlobal += 1;
      }
    }

    const swing = clamp(0.03 + 0.18*expr, 0, 0.22);

    piece = { mood, prompt: prompt || "(no prompt)", mode, key, tempo, stepsPerBar, totalSteps, swing, seq };
    nowPlaying.textContent = `Mood ${mood} · ${instNames[Number(instEl.value)]} · ${tempo} BPM · ${mode.toUpperCase()} · prompt: ${piece.prompt}`;
    log(`Composed piece: ${totalBars} bars, mode=${mode}, key=${key}, tempo=${tempo}.`);
  }

  function adsr(g, t, a, d, s, r, peak) {
    const gg = g.gain;
    gg.cancelScheduledValues(t);
    gg.setValueAtTime(0.0001, t);
    gg.linearRampToValueAtTime(peak, t + a);
    gg.linearRampToValueAtTime(peak*s, t + a + d);
    gg.linearRampToValueAtTime(0.0001, t + a + d + r);
  }

  function makeWaveshaper(amount=1.9) {
    const sh = ctx.createWaveShaper();
    const n = 2048;
    const curve = new Float32Array(n);
    for (let i=0;i<n;i++) {
      const x = (i/(n-1))*2 - 1;
      curve[i] = Math.tanh(amount * x);
    }
    sh.curve = curve;
    return sh;
  }

  function playKick(t, vel=1) {
    const amount = Number(drumsEl.value);
    if (amount <= 0.001) return;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = "sine";
    o.frequency.setValueAtTime(155, t);
    o.frequency.exponentialRampToValueAtTime(48, t + 0.09);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(0.85 * vel * amount, t + 0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.16);
    const sh = makeWaveshaper(2.0);
    o.connect(g); g.connect(sh); sh.connect(drumBus);
    const send = ctx.createGain();
    send.gain.value = 0.04 * amount;
    sh.connect(send); send.connect(revSend);
    o.start(t); o.stop(t + 0.20);
  }

  function playSnare(t, vel=1) {
    const amount = Number(drumsEl.value);
    if (amount <= 0.001) return;
    const n = ctx.createBufferSource();
    const len = Math.floor(ctx.sampleRate * 0.18);
    const b = ctx.createBuffer(1, len, ctx.sampleRate);
    const data = b.getChannelData(0);
    for (let i=0;i<len;i++) data[i] = (Math.random()*2 - 1) * Math.pow(1 - i/len, 1.2);
    n.buffer = b;
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = 1900;
    bp.Q.value = 0.85;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(0.55 * vel * amount, t + 0.003);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.16);
    n.connect(bp); bp.connect(g); g.connect(drumBus);
    const send = ctx.createGain();
    send.gain.value = 0.22 * amount;
    g.connect(send); send.connect(revSend);
    n.start(t); n.stop(t + 0.22);
  }

  function playHat(t, vel=1, intensity=0.5) {
    const amount = Number(drumsEl.value);
    if (amount <= 0.001) return;
    const src = ctx.createBufferSource();
    const len = Math.floor(ctx.sampleRate * 0.05);
    const b = ctx.createBuffer(1, len, ctx.sampleRate);
    const data = b.getChannelData(0);
    for (let i=0;i<len;i++) data[i] = (Math.random()*2 - 1);
    src.buffer = b;
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = 6500 + 900*intensity;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(0.12 * vel * amount, t + 0.001);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.035);
    src.connect(hp); hp.connect(g); g.connect(drumBus);
    src.start(t); src.stop(t + 0.08);
  }

  function playBass(t, midi, dur, vel=1, intensity=0.5) {
    const amount = Number(bassEl.value);
    if (amount <= 0.001 || midi == null) return;
    const freq = midiToHz(midi);
    const o1 = ctx.createOscillator();
    const o2 = ctx.createOscillator();
    o1.type = "sawtooth";
    o2.type = "square";
    o2.detune.value = -11;
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 180 + 520*intensity;
    lp.Q.value = 0.85;
    const g = ctx.createGain();
    const peak = 0.52 * amount * vel;
    adsr(g, t, 0.012, 0.08, 0.40, Math.min(0.22, dur*0.6), peak);
    o1.frequency.setValueAtTime(freq, t);
    o2.frequency.setValueAtTime(freq*0.5, t);
    o1.connect(lp); o2.connect(lp);
    lp.connect(g); g.connect(bassBus);
    const send = ctx.createGain();
    send.gain.value = 0.03 * amount;
    g.connect(send); send.connect(revSend);
    o1.start(t); o2.start(t);
    o1.stop(t + dur); o2.stop(t + dur);
  }

  function playChordPad(t, chordRoot, quality, dur, intensity=0.5) {
    const padAmount = clamp(0.18 + 0.40*intensity, 0.16, 0.75);
    const tones = chordTones(chordRoot, quality);
    const baseMidi = 48;
    const g = ctx.createGain();
    const peak = 0.26 * padAmount;
    adsr(g, t, 0.06, 0.20, 0.62, Math.min(0.34, dur*0.7), peak);
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = 110;
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 900 + 2300*intensity;
    lp.Q.value = 0.65;
    hp.connect(lp); lp.connect(g); g.connect(chordBus);
    const send = ctx.createGain();
    send.gain.value = 0.52 * Number(revEl.value);
    g.connect(send); send.connect(revSend);
    const invChance = 0.25 + 0.35*intensity;
    tones.slice(0,3).forEach((semi, i) => {
      const o = ctx.createOscillator();
      o.type = (i === 0) ? "triangle" : "sine";
      o.detune.value = (i === 1 ? 7 : (i === 2 ? -7 : 0));
      let m = baseMidi + chordRoot + semi;
      if (Math.random() < invChance && i > 0) m += choice([12, 12, 24]);
      o.frequency.setValueAtTime(midiToHz(m), t);
      o.connect(hp);
      o.start(t);
      o.stop(t + dur);
    });
  }

  function playLead(t, midi, dur, vel=1, intensity=0.5) {
    const amount = Number(leadEl.value);
    if (amount <= 0.001 || midi == null) return;
    const inst = Number(instEl.value);
    if (inst === 0) return leadPiano(t, midi, dur, vel, amount);
    if (inst === 1) return leadNylon(t, midi, dur, vel, amount);
    if (inst === 2) return leadElectric(t, midi, dur, vel, amount, intensity);
    if (inst === 3) return leadSax(t, midi, dur, vel, amount);
    return leadKeyboard(t, midi, dur, vel, amount);
  }

  function leadPiano(t, midi, dur, vel, amount) {
    const freq = midiToHz(midi);
    const g = ctx.createGain();
    const peak = 0.34 * amount * vel;
    adsr(g, t, 0.004, 0.12, 0.15, Math.min(0.22, dur*0.6), peak);
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 1400 + 2400*vel;
    lp.Q.value = 0.7;
    lp.connect(g); g.connect(leadBus);
    const send = ctx.createGain();
    send.gain.value = 0.22 * Number(revEl.value);
    g.connect(send); send.connect(revSend);
    const det = 6 + 10*Number(exprEl.value);
    const partials = [
      { mul: 1.0, type: "sine", gain: 1.0 },
      { mul: 2.0, type: "sine", gain: 0.34 },
      { mul: 3.0, type: "triangle", gain: 0.18 },
    ];
    partials.forEach((p, i) => {
      const o = ctx.createOscillator();
      const og = ctx.createGain();
      o.type = p.type;
      o.frequency.setValueAtTime(freq * p.mul, t);
      o.detune.value = (i === 0 ? 0 : (i === 1 ? det : -det));
      og.gain.value = p.gain;
      o.connect(og); og.connect(lp);
      o.start(t); o.stop(t + dur);
    });
  }

  function leadNylon(t, midi, dur, vel, amount) {
    const freq = midiToHz(midi);
    const delayTime = 1 / freq;
    const noise = ctx.createBufferSource();
    const len = Math.floor(ctx.sampleRate * 0.03);
    const b = ctx.createBuffer(1, len, ctx.sampleRate);
    const data = b.getChannelData(0);
    for (let i=0;i<len;i++) data[i] = (Math.random()*2 - 1) * (1 - i/len);
    noise.buffer = b;
    const delay = ctx.createDelay(1.0);
    delay.delayTime.setValueAtTime(delayTime, t);
    const fb = ctx.createGain();
    fb.gain.value = 0.90 - 0.10*(1-vel);
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 2200 + 1700*vel;
    lp.Q.value = 0.62;
    const g = ctx.createGain();
    const peak = 0.40 * amount * vel;
    adsr(g, t, 0.002, 0.10, 0.08, Math.min(0.28, dur*0.7), peak);
    noise.connect(lp);
    lp.connect(delay);
    delay.connect(fb);
    fb.connect(delay);
    delay.connect(g);
    g.connect(leadBus);
    const send = ctx.createGain();
    send.gain.value = 0.18 * Number(revEl.value);
    g.connect(send); send.connect(revSend);
    noise.start(t); noise.stop(t + 0.03);
  }

  function leadElectric(t, midi, dur, vel, amount, intensity) {
    const freq = midiToHz(midi);
    const o = ctx.createOscillator();
    o.type = "sawtooth";
    o.frequency.setValueAtTime(freq, t);
    const g = ctx.createGain();
    const peak = 0.28 * amount * vel;
    adsr(g, t, 0.006, 0.12, 0.22, Math.min(0.34, dur*0.8), peak);
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = 900 + 1400*vel;
    bp.Q.value = 0.95;
    const sh = makeWaveshaper(2.6 + 1.4*intensity);
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 2200 + 1600*vel;
    lp.Q.value = 0.7;
    o.connect(bp); bp.connect(sh); sh.connect(lp); lp.connect(g); g.connect(leadBus);
    const send = ctx.createGain();
    send.gain.value = 0.16 * Number(revEl.value);
    g.connect(send); send.connect(revSend);
    const lfo = ctx.createOscillator();
    const lfoG = ctx.createGain();
    lfo.type = "sine";
    lfo.frequency.value = 4.8 + 1.2*Number(exprEl.value);
    lfoG.gain.value = 8 + 14*Number(exprEl.value);
    lfo.connect(lfoG); lfoG.connect(o.detune);
    lfo.start(t); o.start(t);
    o.stop(t + dur); lfo.stop(t + dur);
  }

  function leadSax(t, midi, dur, vel, amount) {
    const freq = midiToHz(midi);
    const o = ctx.createOscillator();
    o.type = "sawtooth";
    o.frequency.setValueAtTime(freq * (0.98 - 0.01*(1-vel)), t);
    o.frequency.exponentialRampToValueAtTime(freq, t + (0.05 + 0.03*Number(exprEl.value)));
    const g = ctx.createGain();
    const peak = 0.23 * amount * vel;
    adsr(g, t, 0.03, 0.12, 0.48, Math.min(0.26, dur*0.6), peak);
    const f1 = ctx.createBiquadFilter();
    f1.type = "bandpass";
    f1.frequency.value = 650 + 600*vel;
    f1.Q.value = 0.85;
    const f2 = ctx.createBiquadFilter();
    f2.type = "bandpass";
    f2.frequency.value = 1350 + 850*vel;
    f2.Q.value = 0.75;
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 2700 + 1500*vel;
    lp.Q.value = 0.62;
    o.connect(f1); f1.connect(f2); f2.connect(lp); lp.connect(g); g.connect(leadBus);
    const send = ctx.createGain();
    send.gain.value = 0.30 * Number(revEl.value);
    g.connect(send); send.connect(revSend);
    const lfo = ctx.createOscillator();
    const lfoG = ctx.createGain();
    lfo.type = "sine";
    lfo.frequency.value = 5.1;
    lfoG.gain.value = 12 + 16*Number(exprEl.value);
    lfo.connect(lfoG); lfoG.connect(o.detune);
    lfo.start(t); o.start(t);
    o.stop(t + dur); lfo.stop(t + dur);
  }

  function leadKeyboard(t, midi, dur, vel, amount) {
    const freq = midiToHz(midi);
    const o1 = ctx.createOscillator();
    const o2 = ctx.createOscillator();
    o1.type = "sawtooth";
    o2.type = "square";
    o2.detune.value = -14;
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(900 + 600*vel, t);
    lp.frequency.linearRampToValueAtTime(2800 + 2600*vel, t + (0.05 + 0.04*Number(exprEl.value)));
    lp.frequency.linearRampToValueAtTime(1500 + 1200*vel, t + 0.26);
    lp.Q.value = 0.9;
    const g = ctx.createGain();
    const peak = 0.25 * amount * vel;
    adsr(g, t, 0.01, 0.10, 0.30, Math.min(0.22, dur*0.6), peak);
    o1.frequency.setValueAtTime(freq, t);
    o2.frequency.setValueAtTime(freq, t);
    o1.connect(lp); o2.connect(lp); lp.connect(g); g.connect(leadBus);
    const send = ctx.createGain();
    send.gain.value = 0.20 * Number(revEl.value);
    g.connect(send); send.connect(revSend);
    const lfo = ctx.createOscillator();
    const lfoG = ctx.createGain();
    lfo.type = "sine";
    lfo.frequency.value = 4.9;
    lfoG.gain.value = 7 + 12*Number(exprEl.value);
    lfo.connect(lfoG); lfoG.connect(o1.detune); lfoG.connect(o2.detune);
    lfo.start(t); o1.start(t); o2.start(t);
    o1.stop(t + dur); o2.stop(t + dur); lfo.stop(t + dur);
  }

  function stepDurationSec() {
    const tempo = Number(tempoEl.value);
    return (60 / tempo) / 4;
  }

  function microTimingJitterSec(intensity) {
    const e = Number(exprEl.value);
    const max = 0.001 + 0.021*e*(0.5+0.7*intensity);
    return (Math.random()*2 - 1) * max;
  }

  function scheduleStep(stepIndex, baseTime) {
    const st = piece.seq[stepIndex];
    const dur = stepDurationSec() * 0.98;
    const swing = piece.swing;
    const isOff = (stepIndex % 2) === 1;
    const phraseEnd = (st.stepInBar >= 14) ? (0.006 * Number(exprEl.value)) : 0;
    const jitter = microTimingJitterSec(st.intensity);
    const t = baseTime + (isOff ? swing * dur : 0) + jitter + phraseEnd;

    if ((stepIndex % piece.stepsPerBar) === 0) {
      playChordPad(t, st.chordRoot, st.chordQ, stepDurationSec() * piece.stepsPerBar, st.intensity);
    }

    if (st.kick)  playKick(t, 0.95);
    if (st.snare) playSnare(t, 0.92);
    if (st.hat)   playHat(t, 0.85, st.intensity);

    if (st.bass != null) playBass(t, st.bass, stepDurationSec()*2.4, 0.90, st.intensity);
    if (st.lead != null) playLead(t, st.lead, stepDurationSec()*1.8, st.velLead, st.intensity);

    const e = Number(exprEl.value);
    if (st.lead != null && Math.random() < (0.012 + 0.045*e*st.intensity) && st.stepInBar !== 0) {
      const gt = t - (0.035 + 0.02*Math.random());
      playLead(gt, st.lead + choice([-2,-1,1,2]), stepDurationSec()*0.55, clamp(st.velLead*0.55, 0.2, 1), st.intensity);
    }
  }

  function start() {
    if (!ctx) { log("Engine not unlocked yet."); return; }
    if (!piece) composeFromPrompt(true);
    if (playing) return;

    playing = true;
    currentStep = 0;
    let nextTime = ctx.currentTime + 0.06;
    const lookahead = 0.16;
    const intervalMs = 25;

    function tick() {
      if (!playing) return;
      const now = ctx.currentTime;
      while (nextTime < now + lookahead) {
        scheduleStep(currentStep, nextTime);
        nextTime += stepDurationSec();
        currentStep += 1;
        if (currentStep >= piece.totalSteps) {
          playing = false;
          playBtn.disabled = false;
          composeBtn.disabled = false;
          log("Story finished.");
          return;
        }
      }
      stepTimer = setTimeout(tick, intervalMs);
    }
    tick();

    stopBtn.disabled = false;
    playBtn.disabled = true;
    composeBtn.disabled = true;
    log("Playback started.");
  }

  function stop() {
    playing = false;
    if (stepTimer) { clearTimeout(stepTimer); stepTimer = null; }
    playBtn.disabled = false;
    composeBtn.disabled = false;
    stopBtn.disabled = false;
    log("Playback stopped.");
  }

  function updateMix() {
    if (!ctx) return;
    drumBus.gain.value = 0.95 * Number(drumsEl.value);
    bassBus.gain.value = 0.85 * Number(bassEl.value);
    leadBus.gain.value = 0.90 * Number(leadEl.value);
    chordBus.gain.value = 0.60;
    revReturn.gain.value = 0.20 + 0.75 * Number(revEl.value);
    master.gain.value = 0.86;

    if (piece) {
      piece.tempo = Number(tempoEl.value);
      piece.swing = clamp(0.03 + 0.18*Number(exprEl.value), 0, 0.22);
      nowPlaying.textContent = `Mood ${Number(moodEl.value)} · ${instNames[Number(instEl.value)]} · ${Number(tempoEl.value)} BPM · ${piece.mode.toUpperCase()} · prompt: ${piece.prompt}`;
    }
  }

  function drawScope() {
    requestAnimationFrame(drawScope);
    if (!analyser) { sctx.clearRect(0,0,scope.width,scope.height); return; }
    const w = scope.width, h = scope.height;
    const buf = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(buf);
    sctx.clearRect(0,0,w,h);
    sctx.beginPath();
    const step = w / buf.length;
    for (let i=0;i<buf.length;i++) {
      const v = buf[i] / 255;
      const y = v * h;
      const x = i * step;
      if (i === 0) sctx.moveTo(x,y); else sctx.lineTo(x,y);
    }
    sctx.strokeStyle = "rgba(255,255,255,.75)";
    sctx.lineWidth = 1.5;
    sctx.stroke();
  }
  drawScope();

  $("unlockBtn").addEventListener("click", async () => {
    try {
      await unlockAudio();
      playBtn.disabled = false;
      composeBtn.disabled = false;
      stopBtn.disabled = false;
    } catch (e) {
      log(`Unlock error: ${e.message || e}`);
    }
  });

  playBtn.addEventListener("click", async () => {
    try {
      if (!ctx) { log("Tap Start first."); return; }
      if (ctx.state !== "running") await ctx.resume();
      updateMix();
      start();
    } catch (e) { log(`Play failed: ${e.message || e}`); }
  });

  stopBtn.addEventListener("click", () => stop());

  composeBtn.addEventListener("click", () => {
    stop();
    composeFromPrompt(true);
    updateMix();
    log("Composed from prompt.");
  });

  ["input","change"].forEach(ev => {
    [drumsEl,bassEl,leadEl,revEl,exprEl,instEl].forEach(el => el.addEventListener(ev, updateMix, { passive: true }));
  });
  tempoEl.addEventListener("input", () => updateMix(), { passive: true });

  log("Loaded. Tap Start to unlock audio.");
  setEngineOn(false);
})();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>HiFiForge ‚Äî Single‚ÄëFile Music Generator (MVP)</title>
  <style>
    :root { color-scheme: light dark; }
    body{ font-family:-apple-system,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; margin:0; padding:18px; line-height:1.35; }
    h1{ margin:0 0 8px; font-size:20px; }
    .row{ display:flex; gap:12px; flex-wrap:wrap; }
    .card{ border:1px solid rgba(127,127,127,.35); border-radius:16px; padding:14px; box-shadow:0 6px 20px rgba(0,0,0,.08); }
    .col{ flex:1 1 320px; min-width:320px; }
    textarea,input,select{ width:100%; box-sizing:border-box; padding:10px; border-radius:12px; border:1px solid rgba(127,127,127,.35); background:transparent; }
    textarea{ min-height:110px; resize:vertical; }
    label{ display:block; font-size:13px; opacity:.8; margin:10px 0 6px; }
    button{ border:0; border-radius:14px; padding:12px 14px; font-size:16px; cursor:pointer; box-shadow:0 6px 18px rgba(0,0,0,.12); }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .btnrow{ display:flex; gap:10px; flex-wrap:wrap; }
    .small{ font-size:13px; opacity:.8; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; white-space:pre-wrap; }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .slider{ display:flex; align-items:center; gap:10px; }
    .slider input[type=range]{ flex:1; }
    .meter{ height:10px; border-radius:999px; background:rgba(127,127,127,.25); overflow:hidden; }
    .meter > div{ height:100%; width:0%; background: currentColor; opacity:.7; }
    .stem{ display:grid; grid-template-columns: 1fr auto auto; gap:10px; align-items:center; }
    .stem input[type=range]{ width:180px; }
    .pill{ display:inline-block; padding:4px 10px; border-radius:999px; border:1px solid rgba(127,127,127,.35); font-size:12px; opacity:.85; }
    .warn{ color:#ff7b7b; }
    .ok{ color:#7bffb1; }
  </style>
</head>
<body>
  <h1>HiFiForge ‚Äî Single‚ÄëFile Music Generator (MVP)</h1>
  <div class="small">Runs entirely in the browser (no backend). Generates a 2:00‚Äì2:30 multi‚Äëstem instrumental using Web Audio + OfflineAudioContext. iPhone/Safari supported (tap to start audio).</div>

  <div class="row" style="margin-top:14px;">
    <div class="card col">
      <div class="pill">1) Describe the vibe</div>
      <label for="prompt">Prompt</label>
      <textarea id="prompt">Rock-n-roll swagger with arena-stomp energy, danceable groove, crunchy guitars, big chorus lift, modern punch.</textarea>

      <div class="grid2">
        <div>
          <label for="duration">Length</label>
          <select id="duration">
            <option value="130">2:10</option>
            <option value="140" selected>2:20</option>
            <option value="150">2:30</option>
          </select>
        </div>
        <div>
          <label for="seed">Seed (repeatable)</label>
          <input id="seed" value="NEON" />
        </div>
      </div>

      <label>Style DNA (0‚Äì100)</label>
      <div class="slider"><span class="small" style="width:110px;">Swing</span><input id="swing" type="range" min="0" max="100" value="30"><span id="swingV" class="small">30</span></div>
      <div class="slider"><span class="small" style="width:110px;">Aggression</span><input id="aggr" type="range" min="0" max="100" value="65"><span id="aggrV" class="small">65</span></div>
      <div class="slider"><span class="small" style="width:110px;">Chorus size</span><input id="chor" type="range" min="0" max="100" value="85"><span id="chorV" class="small">85</span></div>
      <div class="slider"><span class="small" style="width:110px;">Rockabilly</span><input id="rb" type="range" min="0" max="100" value="35"><span id="rbV" class="small">35</span></div>
      <div class="slider"><span class="small" style="width:110px;">Arena stomp</span><input id="arena" type="range" min="0" max="100" value="80"><span id="arenaV" class="small">80</span></div>
      <div class="slider"><span class="small" style="width:110px;">Pop hook</span><input id="pop" type="range" min="0" max="100" value="70"><span id="popV" class="small">70</span></div>

      <div class="btnrow" style="margin-top:12px;">
        <button id="genBtn">‚ö° Generate full song</button>
        <button id="testBtn">üß™ Run self‚Äëtest</button>
      </div>

      <div style="margin-top:10px;">
        <div class="small">Progress</div>
        <div class="meter"><div id="prog"></div></div>
      </div>

      <div id="status" class="small" style="margin-top:10px;"></div>
      <div id="log" class="mono" style="margin-top:10px; max-height:180px; overflow:auto;"></div>

      <div class="small" style="margin-top:10px;">
        Note: This MVP is procedural synthesis (not Suno/Udio‚Äëstyle model audio). The ‚Äúquality‚Äù improvements here come from stem rendering + mixing + limiting + repeatable structure.
      </div>
    </div>

    <div class="card col">
      <div class="pill">2) Play, mix, edit</div>

      <div class="btnrow" style="margin-top:8px;">
        <button id="playBtn" disabled>‚ñ∂Ô∏è Play</button>
        <button id="stopBtn" disabled>‚èπ Stop</button>
        <button id="exportBtn" disabled>‚¨áÔ∏è Export master WAV</button>
      </div>

      <label style="margin-top:12px;">Section edit (regenerate selection)</label>
      <div class="grid2">
        <select id="sectionSel" disabled></select>
        <button id="regenBtn" disabled>üîÅ Regenerate section</button>
      </div>

      <label style="margin-top:12px;">Stem mixer</label>
      <div id="mixer"></div>

      <label style="margin-top:12px;">Markers</label>
      <div id="markers" class="mono"></div>

      <div class="small" style="margin-top:10px;">
        iPhone tip: if you‚Äôre in silent mode, Safari may still play, but volume might be low‚Äîturn up media volume.
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Utilities ----------
  const $ = (id) => document.getElementById(id);
  const logEl = $('log');
  const statusEl = $('status');
  const progEl = $('prog');

  function log(msg){
    const ts = new Date().toLocaleTimeString();
    logEl.textContent += `[${ts}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function setStatus(msg, cls){
    statusEl.className = 'small ' + (cls || '');
    statusEl.textContent = msg;
  }
  function setProg(p){ progEl.style.width = `${Math.max(0, Math.min(1, p))*100}%`; }

  // Deterministic RNG (Mulberry32) seeded from string
  function xmur3(str){
    let h = 1779033703 ^ str.length;
    for (let i=0; i<str.length; i++) {
      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      h = (h << 13) | (h >>> 19);
    }
    return function(){
      h = Math.imul(h ^ (h >>> 16), 2246822507);
      h = Math.imul(h ^ (h >>> 13), 3266489909);
      return (h ^= (h >>> 16)) >>> 0;
    };
  }
  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  // Simple soft clipper
  function softClip(x){
    const a = 1.2;
    return Math.tanh(a * x) / Math.tanh(a);
  }

  // WAV export (mono or stereo)
  function encodeWav(floatL, floatR, sampleRate){
    const numCh = floatR ? 2 : 1;
    const length = floatL.length;
    const bytesPerSample = 2;
    const blockAlign = numCh * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = length * blockAlign;
    const buffer = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buffer);
    let o=0;
    function writeStr(s){ for(let i=0;i<s.length;i++) view.setUint8(o++, s.charCodeAt(i)); }
    function writeU32(v){ view.setUint32(o, v, true); o+=4; }
    function writeU16(v){ view.setUint16(o, v, true); o+=2; }

    writeStr('RIFF'); writeU32(36 + dataSize); writeStr('WAVE');
    writeStr('fmt '); writeU32(16); writeU16(1);
    writeU16(numCh); writeU32(sampleRate); writeU32(byteRate);
    writeU16(blockAlign); writeU16(16);
    writeStr('data'); writeU32(dataSize);

    // interleave
    for(let i=0;i<length;i++){
      const l = Math.max(-1, Math.min(1, floatL[i]));
      const r = floatR ? Math.max(-1, Math.min(1, floatR[i])) : l;
      view.setInt16(o, Math.round(l*32767), true); o+=2;
      if(numCh===2){ view.setInt16(o, Math.round(r*32767), true); o+=2; }
    }
    return buffer;
  }

  // ---------- Song Blueprint ----------
  function buildBlueprint(opts){
    const seedStr = `${opts.seed}|${opts.prompt}|${opts.swing}|${opts.aggr}|${opts.chor}|${opts.rb}|${opts.arena}|${opts.pop}`;
    const seedFn = xmur3(seedStr);
    const rng = mulberry32(seedFn());

    // Tempo: danceable 118‚Äì128, nudged by arena + pop
    const tempo = Math.round(118 + rng()*6 + (opts.arena/100)*5 + (opts.pop/100)*3);
    const swing = opts.swing/100;

    // Choose a key (minor bias for arena rock)
    const keys = ['E minor','A minor','D minor','G minor','B minor','C minor'];
    const key = keys[Math.floor(rng()*keys.length)];

    // Simple chord progressions (arena-friendly)
    const progs = [
      ['i','bVI','bIII','bVII'],
      ['i','bVII','bVI','bVII'],
      ['i','iv','bVI','bVII'],
      ['i','bIII','iv','bVII'],
    ];
    const prog = progs[Math.floor(rng()*progs.length)];

    // Structure in seconds (approx for 2:10‚Äì2:30)
    const dur = opts.durationSec;
    const sections = [
      {name:'Intro', bars: 4},
      {name:'Verse 1', bars: 16},
      {name:'Pre', bars: 8},
      {name:'Chorus 1', bars: 16},
      {name:'Verse 2', bars: 16},
      {name:'Pre 2', bars: 8},
      {name:'Chorus 2', bars: 16},
      {name:'Bridge', bars: 8},
      {name:'Final Chorus', bars: 16},
      {name:'Outro', bars: 4},
    ];

    // Fit bars to duration by scaling bars uniformly
    const beatsPerBar = 4;
    const secPerBeat = 60/tempo;
    const secPerBar = beatsPerBar * secPerBeat;
    const totalBars = sections.reduce((a,s)=>a+s.bars,0);
    const targetBars = Math.max(48, Math.round(dur / secPerBar));
    const scale = targetBars / totalBars;
    const scaled = sections.map(s => ({...s, bars: Math.max(2, Math.round(s.bars*scale))}));

    // Recompute exact markers
    let barCursor=0;
    const markers = scaled.map(s => {
      const startBar = barCursor;
      barCursor += s.bars;
      return { name: s.name, start: startBar*secPerBar, end: barCursor*secPerBar, startBar, endBar: barCursor };
    });

    const durationSec = markers[markers.length-1].end;

    // Instrumentation & mix targets influenced by sliders
    const aggression = opts.aggr/100;
    const chorusSize = opts.chor/100;
    const rockabilly = opts.rb/100;
    const arena = opts.arena/100;
    const pop = opts.pop/100;

    return {
      seedStr,
      tempo,
      swing,
      key,
      prog,
      durationSec,
      secPerBeat,
      secPerBar,
      markers,
      mix: {
        drumPunch: 0.55 + 0.35*arena,
        bassDrive: 0.35 + 0.40*aggression,
        guitarCrunch: 0.25 + 0.55*aggression,
        chorusLift: 0.15 + 0.55*chorusSize,
        slapEcho: 0.05 + 0.35*rockabilly,
        brightness: 0.45 + 0.35*pop,
      },
      rngSeed: seedFn(),
    };
  }

  // ---------- Synthesis helpers (Offline) ----------
  function mkNoiseBuffer(ctx, seconds){
    const len = Math.floor(seconds * ctx.sampleRate);
    const buf = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = buf.getChannelData(0);
    for(let i=0;i<len;i++) d[i] = (Math.random()*2-1);
    return buf;
  }

  function makeKick(ctx, t, gainNode, toneHz, punch){
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(toneHz*2.2, t);
    osc.frequency.exponentialRampToValueAtTime(toneHz, t+0.04);
    osc.frequency.exponentialRampToValueAtTime(toneHz*0.7, t+0.12);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.9*punch, t+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
    osc.connect(g).connect(gainNode);
    osc.start(t);
    osc.stop(t+0.2);
  }

  function makeSnare(ctx, t, gainNode, noiseBuf, snap){
    const noise = ctx.createBufferSource();
    noise.buffer = noiseBuf;
    const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1200;
    const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1800; bp.Q.value=0.7;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.6*snap, t+0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.16);
    noise.connect(hp).connect(bp).connect(g).connect(gainNode);

    const osc = ctx.createOscillator(); osc.type='triangle';
    osc.frequency.setValueAtTime(210, t);
    const g2 = ctx.createGain();
    g2.gain.setValueAtTime(0.0001, t);
    g2.gain.exponentialRampToValueAtTime(0.25*snap, t+0.003);
    g2.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
    osc.connect(g2).connect(gainNode);

    noise.start(t);
    noise.stop(t+0.2);
    osc.start(t);
    osc.stop(t+0.2);
  }

  function makeHat(ctx, t, gainNode, noiseBuf, amt){
    const src = ctx.createBufferSource(); src.buffer = noiseBuf;
    const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.22*amt, t+0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.04);
    src.connect(hp).connect(g).connect(gainNode);
    src.start(t);
    src.stop(t+0.05);
  }

  function makeBassNote(ctx, t, dur, gainNode, freq, drive){
    const osc = ctx.createOscillator(); osc.type='sawtooth';
    const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 220;
    const g = ctx.createGain();
    osc.frequency.setValueAtTime(freq, t);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.35, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);

    // soft saturation via waveshaper
    const ws = ctx.createWaveShaper();
    const n=1024; const curve=new Float32Array(n);
    for(let i=0;i<n;i++){
      const x = (i/(n-1))*2-1;
      curve[i] = Math.tanh((1+4*drive)*x);
    }
    ws.curve = curve;

    osc.connect(lp).connect(ws).connect(g).connect(gainNode);
    osc.start(t);
    osc.stop(t+dur+0.02);
  }

  function makeChord(ctx, t, dur, gainNode, freqs, crunch, bright){
    // stack 3 saws + gentle chorus via detune
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.26, t+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);

    const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=120;
    const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1200 + 2200*bright;

    // mild drive
    const ws = ctx.createWaveShaper();
    const n=2048; const curve=new Float32Array(n);
    for(let i=0;i<n;i++){
      const x = (i/(n-1))*2-1;
      curve[i] = Math.tanh((1+3*crunch)*x);
    }
    ws.curve = curve;

    hp.connect(lp).connect(ws).connect(g).connect(gainNode);

    const detunes = [-8, 0, 7];
    freqs.forEach((f) => {
      detunes.forEach((d) => {
        const osc = ctx.createOscillator(); osc.type='sawtooth';
        osc.frequency.setValueAtTime(f, t);
        osc.detune.setValueAtTime(d, t);
        osc.connect(hp);
        osc.start(t);
        osc.stop(t+dur+0.03);
      });
    });
  }

  function makeLead(ctx, t, dur, gainNode, freq, echoAmt){
    const osc = ctx.createOscillator(); osc.type='square';
    const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1200; bp.Q.value=0.9;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.16, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);

    // slapback
    const delay = ctx.createDelay(0.25);
    delay.delayTime.value = 0.11;
    const fb = ctx.createGain(); fb.gain.value = 0.18*echoAmt;
    const wet = ctx.createGain(); wet.gain.value = 0.55*echoAmt;
    const dry = ctx.createGain(); dry.gain.value = 1;

    osc.frequency.setValueAtTime(freq, t);
    osc.connect(bp);
    bp.connect(dry).connect(gainNode);
    bp.connect(delay);
    delay.connect(fb).connect(delay);
    delay.connect(wet).connect(gainNode);

    osc.start(t);
    osc.stop(t+dur+0.02);
  }

  // Map Roman-ish degrees in minor to semitone offsets (relative to tonic)
  const DEG = {
    'i': 0,
    'bIII': 3,
    'iv': 5,
    'bVI': 8,
    'bVII': 10,
  };
  const MIN_SCALE = [0,2,3,5,7,8,10];

  function keyToMidiRoot(key){
    // crude: pick tonic midi around 52‚Äì57 for bass
    const map = {
      'C minor':48,'D minor':50,'E minor':52,'G minor':55,'A minor':57,'B minor':59
    };
    return map[key] ?? 52;
  }

  function midiToFreq(m){ return 440 * Math.pow(2,(m-69)/12); }

  function chooseHook(rng, pop){
    // a simple 4-note riff contour
    const hooks = [
      [0, -2, -3, -2],
      [0, -3, -5, -3],
      [0, 2, 0, -2],
      [0, -2, 0, 2],
    ];
    const idx = Math.floor(rng()*hooks.length);
    const base = hooks[idx];
    // pop bias: keep nearer the root (less leaps)
    if(pop > 0.65 && rng() < 0.5) return [0,-2,-2,-3];
    return base;
  }

  function sectionEnergy(name){
    const n = name.toLowerCase();
    if(n.includes('intro')) return 0.45;
    if(n.includes('verse')) return 0.62;
    if(n.includes('pre')) return 0.75;
    if(n.includes('chorus')) return 0.95;
    if(n.includes('bridge')) return 0.70;
    if(n.includes('outro')) return 0.55;
    return 0.7;
  }

  // Render stems into AudioBuffers (stereo)
  async function renderAllStems(blueprint, onProg){
    const sampleRate = 44100;
    const dur = blueprint.durationSec;
    const stems = ['drums','bass','chords','lead'];

    // deterministic rng per render
    const rng = mulberry32(blueprint.rngSeed);

    const rendered = {};
    for(let si=0; si<stems.length; si++){
      const stemName = stems[si];
      onProg?.(0.08 + (si/stems.length)*0.70);
      rendered[stemName] = await renderStem(stemName, blueprint, sampleRate, rng);
    }

    // Mix to master (simple sum + limiter)
    onProg?.(0.82);
    const master = mixMaster(rendered, blueprint);
    onProg?.(0.98);

    return { sampleRate, stems: rendered, master, blueprint };
  }

  async function renderStem(stemName, blueprint, sampleRate, rng){
    const ctx = new OfflineAudioContext({
      numberOfChannels: 2,
      length: Math.ceil(blueprint.durationSec * sampleRate),
      sampleRate,
    });

    const out = ctx.createGain();
    out.gain.value = 1;
    out.connect(ctx.destination);

    // Per-stem gain for mix balance
    const stemGain = ctx.createGain();
    stemGain.connect(out);

    // Light reverb-ish ambience for chorus size (simple feedback delay network)
    const chorusLift = blueprint.mix.chorusLift;
    const ambSend = ctx.createGain(); ambSend.gain.value = 0.12*chorusLift;
    const ambDelay = ctx.createDelay(0.35); ambDelay.delayTime.value = 0.19;
    const ambFb = ctx.createGain(); ambFb.gain.value = 0.18;
    const ambLP = ctx.createBiquadFilter(); ambLP.type='lowpass'; ambLP.frequency.value=2800;
    ambSend.connect(ambDelay); ambDelay.connect(ambFb).connect(ambDelay);
    ambDelay.connect(ambLP).connect(stemGain);

    // noise buffer shared
    const noiseBuf = mkNoiseBuffer(ctx, 0.5);

    // compute chord tones for each prog degree
    const tonic = keyToMidiRoot(blueprint.key);

    function chordMidiForDegree(deg){
      const off = DEG[deg] ?? 0;
      const root = tonic + off;
      // minor triad: 0, 3, 7
      return [root, root+3, root+7];
    }

    // schedule events per bar
    const spb = blueprint.secPerBeat;
    const bars = blueprint.markers[blueprint.markers.length-1].endBar;

    // Hook riff
    const hook = chooseHook(rng, blueprint.mix.brightness);

    // Basic patterns
    for(let b=0; b<bars; b++){
      const tBar = b * blueprint.secPerBar;
      // Determine section and energy
      const sec = blueprint.markers.find(m => b>=m.startBar && b<m.endBar);
      const e = sectionEnergy(sec?.name || '');

      // progression changes every 2 bars
      const progIdx = Math.floor(b/2) % blueprint.prog.length;
      const deg = blueprint.prog[progIdx];
      const chordMidi = chordMidiForDegree(deg);
      const chordFreqs = chordMidi.map(m => midiToFreq(m+12)); // up an octave

      if(stemName === 'drums'){
        const punch = blueprint.mix.drumPunch * (0.75 + 0.35*e);
        // kick on 1 and 3, plus arena stomps in chorus
        makeKick(ctx, tBar + 0*spb, stemGain, 55, punch);
        makeKick(ctx, tBar + 2*spb, stemGain, 55, punch);
        if((sec?.name||'').toLowerCase().includes('chorus') && rng() < 0.65){
          makeKick(ctx, tBar + 1*spb, stemGain, 55, 0.8*punch);
        }
        // snare on 2 and 4
        makeSnare(ctx, tBar + 1*spb, stemGain, noiseBuf, 0.85 + 0.4*e);
        makeSnare(ctx, tBar + 3*spb, stemGain, noiseBuf, 0.85 + 0.4*e);
        // hats: 8ths, with swing
        const swing = blueprint.swing;
        for(let i=0;i<8;i++){
          const beat = i*0.5;
          let tt = tBar + beat*spb;
          // apply swing to off 8ths
          if(i%2===1) tt += swing*(0.08*spb);
          makeHat(ctx, tt, stemGain, noiseBuf, 0.55 + 0.5*e);
        }
      }

      if(stemName === 'bass'){
        const drive = blueprint.mix.bassDrive;
        const root = chordMidi[0]-12;
        const f = midiToFreq(root);
        // 8th-note pulse in chorus, 4ths in verse
        const isCh = (sec?.name||'').toLowerCase().includes('chorus');
        const step = isCh ? 0.5 : 1;
        for(let beat=0; beat<4; beat+=step){
          let tt = tBar + beat*spb;
          if(step===0.5 && (Math.round(beat*2)%2===1)) tt += blueprint.swing*(0.05*spb);
          const dur = step*spb*0.9;
          makeBassNote(ctx, tt, dur, stemGain, f*(rng()<0.12?2:1), drive);
        }
      }

      if(stemName === 'chords'){
        const crunch = blueprint.mix.guitarCrunch;
        const bright = blueprint.mix.brightness;
        // stabs in verse, sustained in chorus
        const isCh = (sec?.name||'').toLowerCase().includes('chorus');
        const isPre = (sec?.name||'').toLowerCase().includes('pre');
        const stab = (!isCh && !isPre);
        if(stab){
          makeChord(ctx, tBar + 0*spb, 0.45*spb, stemGain, chordFreqs, crunch, bright);
          makeChord(ctx, tBar + 2*spb, 0.45*spb, stemGain, chordFreqs, crunch, bright);
        } else {
          makeChord(ctx, tBar + 0*spb, 4*spb*0.98, stemGain, chordFreqs, crunch, bright);
        }
        // send a bit to ambience in choruses
        if(isCh){
          // crude: duplicate a low-level chord to ambience send
          const sendG = ctx.createGain(); sendG.gain.value = 0.35;
          sendG.connect(ambSend);
          makeChord(ctx, tBar + 0*spb, 4*spb*0.98, sendG, chordFreqs, crunch*0.6, bright);
        }
      }

      if(stemName === 'lead'){
        const echoAmt = blueprint.mix.slapEcho;
        const isCh = (sec?.name||'').toLowerCase().includes('chorus');
        const isIntro = (sec?.name||'').toLowerCase().includes('intro');
        const isBridge = (sec?.name||'').toLowerCase().includes('bridge');
        if(isIntro && b < 2) continue;
        // lead enters in pre/chorus more strongly
        const prob = isCh ? 0.95 : (isBridge ? 0.55 : 0.35);
        if(rng() > prob) continue;

        // Build riff over the bar using scale degrees around the chord root
        const rootMidi = chordMidi[0] + 24; // higher register
        const base = rootMidi;
        const steps = 4;
        for(let i=0;i<steps;i++){
          const tt = tBar + (i*1.0)*spb;
          const off = hook[i % hook.length];
          const note = base + off + (rng()<0.15 ? (rng()<0.5?12:-12) : 0);
          const f = midiToFreq(note);
          makeLead(ctx, tt, 0.55*spb, stemGain, f, echoAmt);
        }
      }
    }

    // stem balance
    const mix = blueprint.mix;
    if(stemName==='drums') stemGain.gain.value = 0.95;
    if(stemName==='bass') stemGain.gain.value = 0.70;
    if(stemName==='chords') stemGain.gain.value = 0.72 + 0.18*mix.chorusLift;
    if(stemName==='lead') stemGain.gain.value = 0.55 + 0.25*mix.chorusLift;

    const buffer = await ctx.startRendering();
    return buffer;
  }

  function mixMaster(stems, blueprint){
    const any = stems.drums;
    const sr = any.sampleRate;
    const len = any.length;
    const L = new Float32Array(len);
    const R = new Float32Array(len);

    // Sum stems
    for(const k of Object.keys(stems)){
      const b = stems[k];
      const l = b.getChannelData(0);
      const r = b.getChannelData(1);
      for(let i=0;i<len;i++){
        L[i] += l[i];
        R[i] += r[i];
      }
    }

    // Simple mastering: highpass-ish (DC removal), soft clip, normalize
    // DC removal: subtract running mean (very light)
    let meanL=0, meanR=0;
    const alpha = 0.0005;
    for(let i=0;i<len;i++){
      meanL = (1-alpha)*meanL + alpha*L[i];
      meanR = (1-alpha)*meanR + alpha*R[i];
      L[i] -= meanL;
      R[i] -= meanR;
    }

    // Soft clip and find peak
    let peak=1e-9;
    for(let i=0;i<len;i++){
      const l = softClip(L[i]);
      const r = softClip(R[i]);
      L[i]=l; R[i]=r;
      peak = Math.max(peak, Math.abs(l), Math.abs(r));
    }

    // Normalize to ~ -1dBFS peak
    const target = 0.89;
    const g = target/peak;
    for(let i=0;i<len;i++){
      L[i]*=g; R[i]*=g;
    }

    return { sampleRate: sr, L, R };
  }

  function spliceSection(buffer, replacement, sr, startSec, endSec){
    const start = Math.floor(startSec * sr);
    const end = Math.floor(endSec * sr);
    const fade = Math.floor(0.06 * sr);

    const outL = buffer.L.slice();
    const outR = buffer.R.slice();

    // Copy replacement into region
    for(let i=start; i<end && i<outL.length; i++){
      const j = i - start;
      outL[i] = replacement.L[j] ?? outL[i];
      outR[i] = replacement.R[j] ?? outR[i];
    }

    // Crossfade at boundaries
    for(let i=0; i<fade; i++){
      const a = i/(fade-1);
      const idx1 = start + i;
      const idx2 = end - fade + i;
      if(idx1>=0 && idx1<outL.length){
        outL[idx1] = outL[idx1]*(a) + buffer.L[idx1]*(1-a);
        outR[idx1] = outR[idx1]*(a) + buffer.R[idx1]*(1-a);
      }
      if(idx2>=0 && idx2<outL.length){
        const aa = 1-a;
        outL[idx2] = outL[idx2]*(aa) + buffer.L[idx2]*(1-aa);
        outR[idx2] = outR[idx2]*(aa) + buffer.R[idx2]*(1-aa);
      }
    }

    return { sampleRate: sr, L: outL, R: outR };
  }

  // ---------- Playback engine (real-time) ----------
  let audioCtx = null;
  let sources = null;
  let gains = null;
  let startTime = 0;
  let pauseOffset = 0;
  let current = null; // {sampleRate, stems, master, blueprint}

  function ensureAudioContext(){
    if(audioCtx) return audioCtx;
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!AC) throw new Error('AudioContext not supported in this browser');
    audioCtx = new AC({ latencyHint: 'interactive' });
    return audioCtx;
  }

  function stopPlayback(){
    if(!audioCtx || !sources) return;
    try{
      for(const k of Object.keys(sources)){
        sources[k].stop();
      }
    } catch {}
    sources = null;
    startTime = 0;
    pauseOffset = 0;
    $('playBtn').textContent = '‚ñ∂Ô∏è Play';
  }

  function playOrPause(){
    const ctx = ensureAudioContext();
    if(!current) return;

    if(!sources){
      // start
      sources = {};
      gains = gains || {};
      const master = ctx.createGain();
      master.gain.value = 0.95;
      master.connect(ctx.destination);

      const stemNames = Object.keys(current.stems);
      for(const name of stemNames){
        const b = current.stems[name];
        const src = ctx.createBufferSource();
        src.buffer = b;
        const g = ctx.createGain();
        g.gain.value = mixerState[name]?.gain ?? 1;
        src.connect(g).connect(master);
        sources[name] = src;
        gains[name] = g;
      }

      // start all aligned
      startTime = ctx.currentTime - pauseOffset;
      for(const name of Object.keys(sources)){
        sources[name].start(0, pauseOffset);
      }
      $('playBtn').textContent = '‚è∏ Pause';
      setStatus('Playing‚Ä¶', 'ok');

      // onended (rough)
      const dur = current.blueprint.durationSec;
      window.clearTimeout(window.__endTimer);
      window.__endTimer = window.setTimeout(() => {
        if(sources){ stopPlayback(); setStatus('Finished.', ''); }
      }, Math.max(0, (dur - pauseOffset + 0.1)*1000));

    } else {
      // pause
      const off = ctx.currentTime - startTime;
      pauseOffset = off;
      stopPlayback();
      pauseOffset = off;
      $('playBtn').textContent = '‚ñ∂Ô∏è Resume';
      setStatus('Paused.', '');
    }
  }

  // ---------- UI: Mixer ----------
  const mixerState = {
    drums:{gain:1}, bass:{gain:1}, chords:{gain:1}, lead:{gain:1}
  };

  function renderMixer(){
    const mixer = $('mixer');
    mixer.innerHTML = '';
    const stemNames = ['drums','bass','chords','lead'];

    for(const name of stemNames){
      const row = document.createElement('div');
      row.className = 'stem';

      const lbl = document.createElement('div');
      lbl.textContent = name;
      lbl.className = 'small';

      const slider = document.createElement('input');
      slider.type='range'; slider.min='0'; slider.max='120'; slider.value = String(Math.round((mixerState[name].gain||1)*100));
      slider.addEventListener('input', () => {
        mixerState[name].gain = Number(slider.value)/100;
        if(gains?.[name]) gains[name].gain.value = mixerState[name].gain;
      });

      const btn = document.createElement('button');
      btn.textContent='Mute';
      btn.style.padding='8px 10px';
      btn.style.fontSize='13px';
      btn.addEventListener('click', () => {
        const muted = mixerState[name].gain === 0;
        mixerState[name].gain = muted ? 1 : 0;
        slider.value = muted ? '100' : '0';
        if(gains?.[name]) gains[name].gain.value = mixerState[name].gain;
        btn.textContent = muted ? 'Mute' : 'Unmute';
      });

      row.appendChild(lbl);
      row.appendChild(slider);
      row.appendChild(btn);
      mixer.appendChild(row);
    }
  }

  renderMixer();

  // ---------- Self-test ----------
  async function selfTest(){
    logEl.textContent='';
    setProg(0);
    setStatus('Running self-test‚Ä¶', '');

    const AC = window.AudioContext || window.webkitAudioContext;
    if(!AC){ setStatus('‚ùå AudioContext not supported.', 'warn'); return; }
    log('AudioContext available ‚úÖ');

    // Offline render 1s and verify buffer non-silent
    const sr = 44100;
    const ctx = new OfflineAudioContext({numberOfChannels:2, length: sr*1, sampleRate: sr});
    const g = ctx.createGain(); g.gain.value=0.4; g.connect(ctx.destination);
    const osc = ctx.createOscillator(); osc.type='sine'; osc.frequency.value=220;
    osc.connect(g); osc.start(0); osc.stop(1);
    const buf = await ctx.startRendering();
    log('OfflineAudioContext render ‚úÖ');

    const d = buf.getChannelData(0);
    let rms=0;
    for(let i=0;i<d.length;i++) rms += d[i]*d[i];
    rms = Math.sqrt(rms/d.length);
    log(`RMS check: ${rms.toFixed(4)} (should be > 0.01)`);
    if(rms < 0.01){ setStatus('‚ùå Render seems silent in this environment.', 'warn'); return; }

    setStatus('‚úÖ Self-test passed. Tap ‚ÄúGenerate full song‚Äù.', 'ok');
    setProg(1);
  }

  // ---------- Generate + Regenerate ----------
  function getOpts(){
    return {
      prompt: $('prompt').value.trim(),
      durationSec: Number($('duration').value),
      seed: $('seed').value.trim() || 'SEED',
      swing: Number($('swing').value),
      aggr: Number($('aggr').value),
      chor: Number($('chor').value),
      rb: Number($('rb').value),
      arena: Number($('arena').value),
      pop: Number($('pop').value),
    };
  }

  function fillSections(markers){
    const sel = $('sectionSel');
    sel.innerHTML='';
    markers.forEach((m, idx) => {
      const opt = document.createElement('option');
      opt.value = String(idx);
      opt.textContent = `${m.name} (${m.start.toFixed(1)}s‚Äì${m.end.toFixed(1)}s)`;
      sel.appendChild(opt);
    });
  }

  async function generateFull(){
    // reset
    logEl.textContent='';
    setProg(0);
    setStatus('Generating‚Ä¶', '');

    $('genBtn').disabled = true;
    $('regenBtn').disabled = true;
    $('playBtn').disabled = true;
    $('stopBtn').disabled = true;
    $('exportBtn').disabled = true;
    $('sectionSel').disabled = true;

    stopPlayback();

    try{
      const opts = getOpts();
      const bp = buildBlueprint(opts);
      log(`Blueprint: tempo ${bp.tempo} BPM, key ${bp.key}, duration ~${bp.durationSec.toFixed(1)}s`);
      log(`Progression: ${bp.prog.join(' - ')}`);

      const result = await renderAllStems(bp, (p)=>setProg(p));
      current = result;

      // UI
      $('playBtn').disabled = false;
      $('stopBtn').disabled = false;
      $('exportBtn').disabled = false;
      $('sectionSel').disabled = false;
      $('regenBtn').disabled = false;

      fillSections(bp.markers);
      $('markers').textContent = bp.markers.map(m => `${m.name.padEnd(12)}  ${m.start.toFixed(2)}s -> ${m.end.toFixed(2)}s`).join('\n');

      setStatus('‚úÖ Generated. Tap Play.', 'ok');
      setProg(1);

    } catch(e){
      console.error(e);
      setStatus('‚ùå Generation failed: ' + (e?.message || e), 'warn');
      log('Error: ' + (e?.stack || e));
    } finally {
      $('genBtn').disabled = false;
    }
  }

  async function regenerateSection(){
    if(!current) return;
    const idx = Number($('sectionSel').value);
    const m = current.blueprint.markers[idx];
    if(!m) return;

    $('regenBtn').disabled = true;
    setStatus(`Regenerating ${m.name}‚Ä¶`, '');
    setProg(0);

    try{
      const bp = current.blueprint;
      // build a mini-blueprint for just this region but keep same tempo/key/prog
      const mini = {
        ...bp,
        durationSec: (m.end - m.start),
        markers: [{name:m.name, start:0, end:(m.end-m.start), startBar:0, endBar:(m.endBar - m.startBar)}],
        rngSeed: xmur3(bp.seedStr + '|regen|' + m.name)(),
      };

      const rng = mulberry32(mini.rngSeed);
      const sampleRate = current.sampleRate;

      // Render each stem for section
      const replStems = {};
      const stemNames = Object.keys(current.stems);
      for(let i=0;i<stemNames.length;i++){
        setProg((i/stemNames.length)*0.8);
        replStems[stemNames[i]] = await renderStem(stemNames[i], mini, sampleRate, rng);
      }

      // Mix replacement master for the region
      const replMaster = mixMaster(replStems, mini);

      // Splice master (for export) and splice stems (for playback)
      for(const name of stemNames){
        const orig = current.stems[name];
        const oL = orig.getChannelData(0);
        const oR = orig.getChannelData(1);
        const rL = replStems[name].getChannelData(0);
        const rR = replStems[name].getChannelData(1);

        const sr = sampleRate;
        const start = Math.floor(m.start * sr);
        const end = Math.floor(m.end * sr);
        const fade = Math.floor(0.06 * sr);

        // Copy with crossfade
        for(let i=start; i<end && i<orig.length; i++){
          const j = i-start;
          let nl = rL[j] ?? oL[i];
          let nr = rR[j] ?? oR[i];

          // fade in/out
          if(i < start + fade){
            const a = (i-start)/(fade-1);
            nl = nl*a + oL[i]*(1-a);
            nr = nr*a + oR[i]*(1-a);
          }
          if(i > end - fade){
            const a = (end - i)/(fade-1);
            nl = nl*a + oL[i]*(1-a);
            nr = nr*a + oR[i]*(1-a);
          }

          oL[i]=nl; oR[i]=nr;
        }
      }

      // splice master
      current.master = spliceSection(current.master, replMaster, current.sampleRate, m.start, m.end);

      // if currently playing, restart at same offset
      const wasPlaying = !!sources;
      const ctx = audioCtx;
      let offset = pauseOffset;
      if(wasPlaying && ctx){
        offset = ctx.currentTime - startTime;
        stopPlayback();
        pauseOffset = offset;
        playOrPause();
      }

      setProg(1);
      setStatus(`‚úÖ Regenerated ${m.name}.`, 'ok');

    } catch(e){
      console.error(e);
      setStatus('‚ùå Regen failed: ' + (e?.message || e), 'warn');
      log('Error: ' + (e?.stack || e));
    } finally {
      $('regenBtn').disabled = false;
    }
  }

  function exportMaster(){
    if(!current) return;
    const wav = encodeWav(current.master.L, current.master.R, current.sampleRate);
    const blob = new Blob([wav], {type:'audio/wav'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `hififorge_${(current.blueprint.key||'key').replace(' ','_')}_${current.blueprint.tempo}bpm.wav`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 4000);
  }

  // ---------- Wire UI ----------
  const sliders = ['swing','aggr','chor','rb','arena','pop'];
  sliders.forEach(id => {
    $(id).addEventListener('input', () => { $(id+'V').textContent = $(id).value; });
    $(id+'V').textContent = $(id).value;
  });

  $('testBtn').addEventListener('click', selfTest);
  $('genBtn').addEventListener('click', generateFull);
  $('playBtn').addEventListener('click', () => {
    try { playOrPause(); } catch(e){ setStatus('‚ùå ' + (e?.message||e), 'warn'); }
  });
  $('stopBtn').addEventListener('click', () => { stopPlayback(); setStatus('Stopped.', ''); });
  $('exportBtn').addEventListener('click', exportMaster);
  $('regenBtn').addEventListener('click', regenerateSection);

  // Disable accidental scrolling zoom on iOS while dragging sliders
  document.addEventListener('touchmove', (e) => {
    if(e.target && e.target.tagName === 'INPUT' && e.target.type === 'range'){
      e.preventDefault();
    }
  }, {passive:false});

  setStatus('Ready. Run self-test, then generate.', '');
})();
</script>
</body>
</html>
